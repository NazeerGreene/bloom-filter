package learn.controller;

import learn.dictionary.Read;
import learn.dictionary.Write;
import learn.hash.FNV1A64;
import learn.hash.QuickHash;
import learn.utils.BloomFilter;
import learn.utils.BuildInfo;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.List;

import static learn.dictionary.Read.countNewlines;

/**
 * The interface to manage the control flow between the program and the user.
 * Do not modify files saved by the controller.
 *
 * Seeds for hashing algorithm should be placed in './data/seeds.csv' for initial dictionary build.
 * After initial build, no need to modify 'seeds.csv'.
 */
public class Controller {
    // Related to Bloom filter
    private BloomFilter filter;
    private double desiredFP; // false positivity probability
    private QuickHash hash;
    private int[] seeds;

    // File locations
    private static final String DATA_DIRECTORY = "./data/test/";
    private static final String COMPILED_DICTIONARY_PATH = DATA_DIRECTORY + "dict-compiled.bf";
    private static final String SEEDS_FILE = DATA_DIRECTORY + "seeds.csv";

    // setters
    public void setDesiredFP(double newValue) {
        this.desiredFP = newValue;
    }

    public void setHash(QuickHash hash) {
        this.hash = hash;
    }

    public void setSeeds(int[] seeds) {
        this.seeds = seeds;
    }

    // Constructors
    public Controller() throws IOException {
        this.filter = null;
        this.desiredFP = BloomFilter.DFP_DEFAULT;
        this.hash = FNV1A64::hash;
        this.seeds = Read.getSeedsFromCSV(SEEDS_FILE);
    }

    // either we build the filter or we check the filter for members
    public void run(List<String> args) throws IOException {
        if (args.isEmpty()) {
            throw new IllegalArgumentException("Missing command: build <filename>, check [arg...]");
        }

        List<String> notFound;
        String command = args.removeFirst();

        switch (command) {
            case "build", "-b":
                buildFilter(args.removeFirst());
                return;
            case "check", "-c":
                notFound = checkFilterFor(args);
                break;
            default:
                throw new IllegalArgumentException("Missing command: build <filename>, check [arg...]");
        }

        System.out.println("Not found in dictionary:");
        notFound.forEach(System.out::println);
    }

    /**
     * The method to compile raw text into a bloom filter
     * @param rawDictionary The text file containing the elements to compile into a Bloom filter
     * @return true If Bloom filter was successfully built and saved to disk
     *         false If Bloom filter was not successfully built
     * @throws IOException If problems occur reading file provided by rawDictionary;
     *                     or, if too few number of seeds provided in seeds.csv
     */
    private boolean buildFilter(String rawDictionary) throws IOException {
        if (null == rawDictionary) {
            return false;
        }

        // first we should verify that we have all the necessary components
        int nElementsInDictionary = countNewlines(rawDictionary);
        int bitsRequired = BloomFilter.calculateBitArraySize(desiredFP, nElementsInDictionary);
        int nHashFunctions = BloomFilter.calculateNumOfHashFunctions(bitsRequired, nElementsInDictionary);

        if (null == seeds || seeds.length < nHashFunctions) {
            return false;
        }

        // build the filter
        filter = new BloomFilter(desiredFP, hash, Arrays.copyOf(seeds, nHashFunctions));
        filter.build(nElementsInDictionary);

        // add elements to filter
        Read.dictFromRawSource(rawDictionary, filter);

        // save filter to memory
        byte[] header = new BuildInfo((short) nHashFunctions, bitsRequired).generateByteHeader();
        byte[] dictionary = filter.getBitArray().toByteArray();

        Write.dictToBinaryFile(COMPILED_DICTIONARY_PATH, header, dictionary);
        Write.seedsToCsvFile(SEEDS_FILE, filter.getSeeds());

        // finished
        return true;
    }

    /**
     * The method to check elements in a compiled filter. Assumes buildFilter() has already been invoked and
     * the filter has been compiled separately.
     * @param elementsToCheck The list of Strings to check against the filter
     * @return The elements not present in the filter
     * @throws IOException If problems occur reading filter binary file generated by buildFilter()
     */
    private List<String> checkFilterFor(List<String> elementsToCheck) throws IOException {
        // read the dictionary from memory
        byte[] dictionaryBinaryData = Read.dictFromCompiledSource(COMPILED_DICTIONARY_PATH, null);

        // build the filter
        BitSet data = BitSet.valueOf(dictionaryBinaryData);
        filter = new BloomFilter(desiredFP, hash, seeds);
        filter.build(data);

        if (null == filter) {
            return null;
        }

        // for each element to check, run through filter
        ArrayList<String> notFound = new ArrayList<>();

        for(String element: elementsToCheck) {
            if (!filter.contains(element)) {
                notFound.add(element);
            }
        }

        // return list
        return notFound;
    }
}
